/*

试题编号：	201312-4
试题名称：	有趣的数
时间限制：	1.0s
内存限制：	256.0MB
问题描述：	
问题描述
　　我们把一个数称为有趣的，当且仅当：
　　1. 它的数字只包含0, 1, 2, 3，且这四个数字都出现过至少一次。
　　2. 所有的0都出现在所有的1之前，而所有的2都出现在所有的3之前。
　　3. 最高位数字不为0。
　　因此，符合我们定义的最小的有趣的数是2013。除此以外，4位的有趣的数还有两个：2031和2301。
　　请计算恰好有n位的有趣的数的个数。由于答案可能非常大，只需要输出答案除以1000000007的余数。
输入格式
　　输入只有一行，包括恰好一个正整数n (4 ≤ n ≤ 1000)。
输出格式
　　输出只有一行，包括恰好n 位的整数中有趣的数的个数除以1000000007的余数。
样例输入
4
样例输出
3

*/


// 用动态规划解  参考链接：https://www.cnblogs.com/tgycoder/p/5052109.html
// 总共6种状态，分别是数字只包含 2 、 02 、 012、 23 、 023 、0123 这六种
// dp[i][j] i 为前 i位  ， j 为某个状态

// dp[i][j] 的含义为  前i位在状态 j 的时候有趣数的个数
// 所以我们最后要求的答案是 dp[N][5]




#include <bits/stdc++.h>
using namespace  std;


const int Mod = 1000000007;
const int N = 1003;
long long dp[N][6];
int main(int argc, char const *argv[])
{
	
	int n ; 
	while(cin>>n){
		 for(int i = 0;i<6;i++)
            dp[0][i] = 0;
		for(int i = 1 ; i <= n ; i++){
			dp[i][0] =  1; //集合只有2的时候只有全是2的这一种情况
			dp[i][1] = (dp[i-1][0] + dp[i-1][1]*2) %Mod; //集合02 状态可能是dp[i-1][0]加一个2 得到的，也可能自己加0或2
			dp[i][2] = (dp[i-1][0] + dp[i-1][2] )%Mod; //集合23由dp[i-1][0]加3或者自加3
			dp[i][3] = (dp[i-1][1] + dp[i-1][3]*2)%Mod; //集合012由dp[i-1][1]加1或者自加1或2
			dp[i][4] = (dp[i-1][1] + dp[i-1][2] + dp[i-1][4]*2) %Mod;//集合023由dp[i-1][1]加3或者dp[i][2]加0或者自加0或3
			dp[i][5] = (dp[i-1][3] + dp[i-1][4] + dp[i-1][5]*2) %Mod;
			//集合0123由dp[i-1][3]加3 dp[i-1][4]加1 或者自加 1 3
		}

	dp[n][5] %= Mod;
	printf("%d\n",dp[n][5]);
}
	return 0;
}

       






